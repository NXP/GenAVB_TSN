<!-- HTML header for doxygen 1.8.5-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>GenAVB/TSN: Streaming</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script src="http://www.freescale.com/files/abstract/misc/COLLATERALTEMPLATE_infocenter.js" type="text/javascript" xml:space="preserve"><!-- --></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="html_custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="nxp_logo.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">GenAVB/TSN
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__stream.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">Modules</a> &#124;
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Streaming<div class="ingroups"><a class="el" href="group__library.html">Library API</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Overview</h2>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:group__avdecc__format"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__avdecc__format.html">Avdecc_format</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:structgenavb__stream__params"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__stream.html#structgenavb__stream__params">genavb_stream_params</a></td></tr>
<tr class="separator:structgenavb__stream__params"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structgenavb__stream__params_8talker"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__stream.html#structgenavb__stream__params_8talker">genavb_stream_params.talker</a></td></tr>
<tr class="separator:structgenavb__stream__params_8talker"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structgenavb__iovec"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__stream.html#structgenavb__iovec">genavb_iovec</a></td></tr>
<tr class="separator:structgenavb__iovec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structgenavb__event"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__stream.html#structgenavb__event">genavb_event</a></td></tr>
<tr class="separator:structgenavb__event"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gaeec7fa07053dd385e126e0d8cadb6006"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__stream.html#gaeec7fa07053dd385e126e0d8cadb6006">SR_CLASS_A_MAX_TIMING_UNCERTAINTY</a>&#160;&#160;&#160;125000</td></tr>
<tr class="separator:gaeec7fa07053dd385e126e0d8cadb6006"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga85e282bda3eed89c6943b31df3b69515"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__stream.html#ga85e282bda3eed89c6943b31df3b69515">avtp_direction_t</a> { <br />
&#160;&#160;<a class="el" href="group__stream.html#gga85e282bda3eed89c6943b31df3b69515a63caa6b27fa2daedc4403e7291aeec4d">AVTP_DIRECTION_LISTENER</a> = 0, 
<br />
&#160;&#160;<a class="el" href="group__stream.html#gga85e282bda3eed89c6943b31df3b69515a2ef2404bd96ea075fb8271c432144402">AVTP_DIRECTION_TALKER</a>
<br />
 }</td></tr>
<tr class="separator:ga85e282bda3eed89c6943b31df3b69515"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga549fd464aad79090311d03274e0f5ffb"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__stream.html#ga549fd464aad79090311d03274e0f5ffb">genavb_clock_domain_t</a> { <br />
&#160;&#160;<b>GENAVB_CLOCK_DOMAIN_DEFAULT</b> = 0, 
<br />
&#160;&#160;<a class="el" href="group__stream.html#gga549fd464aad79090311d03274e0f5ffbac4ba9bb2e9e1a4aa7239ef45cef8ce42">GENAVB_MEDIA_CLOCK_DOMAIN_PTP</a>, 
<br />
&#160;&#160;<a class="el" href="group__stream.html#gga549fd464aad79090311d03274e0f5ffba0260ee5b31eeb1468a3af56e7e47264a">GENAVB_MEDIA_CLOCK_DOMAIN_STREAM</a>, 
<br />
&#160;&#160;<a class="el" href="group__stream.html#gga549fd464aad79090311d03274e0f5ffba36e51ee61f4055e27b8eeaa91da8fba1">GENAVB_MEDIA_CLOCK_DOMAIN_MASTER_CLK</a>, 
<br />
&#160;&#160;<a class="el" href="group__stream.html#gga549fd464aad79090311d03274e0f5ffba8c091920cc20d6a31ae74f719c1b4862">GENAVB_CLOCK_DOMAIN_0</a> = 10, 
<br />
&#160;&#160;<a class="el" href="group__stream.html#gga549fd464aad79090311d03274e0f5ffbaa486fe54ebfcb15d90293de73cf25017">GENAVB_CLOCK_DOMAIN_1</a>, 
<br />
&#160;&#160;<a class="el" href="group__stream.html#gga549fd464aad79090311d03274e0f5ffba1d360ef40b5c8360f5a4b13fc2cbd0af">GENAVB_CLOCK_DOMAIN_2</a>, 
<br />
&#160;&#160;<a class="el" href="group__stream.html#gga549fd464aad79090311d03274e0f5ffba616788badeb6b2e6a26608a0c22952aa">GENAVB_CLOCK_DOMAIN_3</a>, 
<br />
&#160;&#160;<b>GENAVB_CLOCK_DOMAIN_MAX</b>
<br />
 }</td></tr>
<tr class="separator:ga549fd464aad79090311d03274e0f5ffb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae169475c394476b5cfc78a81a8fbc8f9"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__stream.html#gae169475c394476b5cfc78a81a8fbc8f9">genavb_stream_flags_t</a> { <br />
&#160;&#160;<a class="el" href="group__stream.html#ggae169475c394476b5cfc78a81a8fbc8f9acbf8c5c84576d43be7cc9e20767f0656">GENAVB_STREAM_FLAGS_MCR</a> = (1 &lt;&lt; 0), 
<br />
&#160;&#160;<a class="el" href="group__stream.html#ggae169475c394476b5cfc78a81a8fbc8f9ad49344af8b4c68682fc51aa45d94eaf8">GENAVB_STREAM_FLAGS_CUSTOM_TSPEC</a> = (1 &lt;&lt; 1)
<br />
 }</td></tr>
<tr class="separator:gae169475c394476b5cfc78a81a8fbc8f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3f41b80b144c62352d1b276e9efa99b8"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__stream.html#ga3f41b80b144c62352d1b276e9efa99b8">genavb_stream_create_flags_t</a> { <br />
&#160;&#160;<a class="el" href="group__stream.html#gga3f41b80b144c62352d1b276e9efa99b8ac185e51577304e6ae9515774d85eb714">AVTP_NONBLOCK</a> = (1 &lt;&lt; 0), 
<br />
&#160;&#160;<a class="el" href="group__stream.html#gga3f41b80b144c62352d1b276e9efa99b8a199c3a08feba937f632cb892c89566b5">AVTP_DGRAM</a> = (1 &lt;&lt; 1)
<br />
 }</td></tr>
<tr class="separator:ga3f41b80b144c62352d1b276e9efa99b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga8b670c4f794059248df5d3554912d6ae"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__stream.html#ga8b670c4f794059248df5d3554912d6ae">genavb_stream_fd</a> (struct genavb_stream_handle const *stream)</td></tr>
<tr class="separator:ga8b670c4f794059248df5d3554912d6ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae0d4f045db318cc5fcc32bb699051ea9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__stream.html#gae0d4f045db318cc5fcc32bb699051ea9">genavb_stream_h264_send</a> (struct genavb_stream_handle *stream, void *data, unsigned int data_len, struct <a class="el" href="group__stream.html#structgenavb__event">genavb_event</a> *event, unsigned int event_len)</td></tr>
<tr class="separator:gae0d4f045db318cc5fcc32bb699051ea9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae648eae79fa8c289147375d0410945b1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__stream.html#gae648eae79fa8c289147375d0410945b1">genavb_stream_receive_iov</a> (struct genavb_stream_handle const *stream, struct <a class="el" href="group__stream.html#structgenavb__iovec">genavb_iovec</a> const *data_iov, unsigned int data_iov_len, struct <a class="el" href="group__stream.html#structgenavb__iovec">genavb_iovec</a> const *event_iov, unsigned int event_iov_len, unsigned int *event_len)</td></tr>
<tr class="separator:gae648eae79fa8c289147375d0410945b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab809c4255477d9a3745386f5aaedd791"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__stream.html#gab809c4255477d9a3745386f5aaedd791">genavb_stream_send_iov</a> (struct genavb_stream_handle const *stream, struct <a class="el" href="group__stream.html#structgenavb__iovec">genavb_iovec</a> const *data_iov, unsigned int data_iov_len, struct <a class="el" href="group__stream.html#structgenavb__event">genavb_event</a> const *event, unsigned int event_len)</td></tr>
<tr class="separator:gab809c4255477d9a3745386f5aaedd791"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1edca94485ef63e234a5012187255588"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__stream.html#ga1edca94485ef63e234a5012187255588">genavb_stream_create</a> (struct genavb_handle *genavb, struct genavb_stream_handle **stream, struct <a class="el" href="group__stream.html#structgenavb__stream__params">genavb_stream_params</a> const *params, unsigned int *batch_size, <a class="el" href="group__stream.html#ga3f41b80b144c62352d1b276e9efa99b8">genavb_stream_create_flags_t</a> flags)</td></tr>
<tr class="separator:ga1edca94485ef63e234a5012187255588"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3f6239c9a0914082dd5fd76f0507e5b4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__stream.html#ga3f6239c9a0914082dd5fd76f0507e5b4">genavb_stream_receive</a> (struct genavb_stream_handle const *stream, void *data, unsigned int data_len, struct <a class="el" href="group__stream.html#structgenavb__event">genavb_event</a> *event, unsigned int *event_len)</td></tr>
<tr class="separator:ga3f6239c9a0914082dd5fd76f0507e5b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga04dfd629347336da56741cbabf021bf5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__stream.html#ga04dfd629347336da56741cbabf021bf5">genavb_stream_send</a> (struct genavb_stream_handle const *stream, void const *data, unsigned int data_len, struct <a class="el" href="group__stream.html#structgenavb__event">genavb_event</a> const *event, unsigned int event_len)</td></tr>
<tr class="separator:ga04dfd629347336da56741cbabf021bf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8ad1f9febe073b91fadc3b3aca802398"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__stream.html#ga8ad1f9febe073b91fadc3b3aca802398">genavb_stream_destroy</a> (struct genavb_stream_handle *stream)</td></tr>
<tr class="separator:ga8ad1f9febe073b91fadc3b3aca802398"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4f6aed0067e1082cb5937579af68f842"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__stream.html#ga4f6aed0067e1082cb5937579af68f842">genavb_stream_presentation_offset</a> (const struct genavb_stream_handle *handle)</td></tr>
<tr class="separator:ga4f6aed0067e1082cb5937579af68f842"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga142b8be7c08359eaad4ba358ca439c4a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__stream.html#ga142b8be7c08359eaad4ba358ca439c4a">AVTP_MEDIA_CLOCK_RESTART</a>&#160;&#160;&#160;(1 &lt;&lt; 0)</td></tr>
<tr class="separator:ga142b8be7c08359eaad4ba358ca439c4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaabac3d782b8271940bda704fc61af46a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__stream.html#gaabac3d782b8271940bda704fc61af46a">AVTP_PACKET_LOST</a>&#160;&#160;&#160;(1 &lt;&lt; 1)</td></tr>
<tr class="separator:gaabac3d782b8271940bda704fc61af46a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga36b7375f8d60ce9b0886814010a9fa1a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__stream.html#ga36b7375f8d60ce9b0886814010a9fa1a">AVTP_TIMESTAMP_UNCERTAIN</a>&#160;&#160;&#160;(1 &lt;&lt; 2)</td></tr>
<tr class="separator:ga36b7375f8d60ce9b0886814010a9fa1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5b3fb974cb1ea2d99de92d85e786e938"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__stream.html#ga5b3fb974cb1ea2d99de92d85e786e938">AVTP_END_OF_FRAME</a>&#160;&#160;&#160;(1 &lt;&lt; 14)</td></tr>
<tr class="separator:ga5b3fb974cb1ea2d99de92d85e786e938"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga88c1c6af5065f0f5e009f83093df1a2a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__stream.html#ga88c1c6af5065f0f5e009f83093df1a2a">AVTP_TIMESTAMP_INVALID</a>&#160;&#160;&#160;(1 &lt;&lt; 15)</td></tr>
<tr class="separator:ga88c1c6af5065f0f5e009f83093df1a2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga31ffedf58931d498048116f43ba42cea"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__stream.html#ga31ffedf58931d498048116f43ba42cea">AVTP_SYNC</a>&#160;&#160;&#160;(1 &lt;&lt; 0)</td></tr>
<tr class="separator:ga31ffedf58931d498048116f43ba42cea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga95b57551cb8d38631d7482b0cd7f7549"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__stream.html#ga95b57551cb8d38631d7482b0cd7f7549">AVTP_FLUSH</a>&#160;&#160;&#160;(1 &lt;&lt; 1)</td></tr>
<tr class="separator:ga95b57551cb8d38631d7482b0cd7f7549"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a0a46f6e4ddfa6236496dae45c98198"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__stream.html#ga5a0a46f6e4ddfa6236496dae45c98198">AVTP_FRAME_END</a>&#160;&#160;&#160;(1 &lt;&lt; 2)</td></tr>
<tr class="separator:ga5a0a46f6e4ddfa6236496dae45c98198"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<hr/><h2 class="groupheader">Data Structure Documentation</h2>
<a name="structgenavb__stream__params" id="structgenavb__stream__params"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct genavb_stream_params</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Stream creation parameters. </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a class="anchor" id="ad316d5a04440b8d3548de78ee5956757"></a><a class="el" href="group__stream.html#ga85e282bda3eed89c6943b31df3b69515">avtp_direction_t</a></td>
<td class="fieldname">
direction</td>
<td class="fielddoc">
Stream direction. </td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="aadbb230543ba65b80fd3ffdaf3ccba13"></a>avb_u8</td>
<td class="fieldname">
subtype</td>
<td class="fielddoc">
Stream subtype (1722-2011 Table 5.2, 1722-2016 Table 6) </td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a36fc242a2e08649877d4ff2f571b2555"></a>avb_u16</td>
<td class="fieldname">
port</td>
<td class="fielddoc">
Network port. </td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a649655317225db15d9721042143fc323"></a>sr_class_t</td>
<td class="fieldname">
stream_class</td>
<td class="fielddoc">
Stream class. </td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a185f91542be150d67843404681447fd0"></a>avb_u8</td>
<td class="fieldname">
stream_id[8]</td>
<td class="fielddoc">
Stream ID (in network order) </td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a5a7f74a6ee074d393c4c4e4b2426b241"></a>avb_u8</td>
<td class="fieldname">
dst_mac[6]</td>
<td class="fielddoc">
Stream destination mac address (in network order), needs to be specified for both listener and talker cases. </td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="aa67a91c8a43125d74296e5538c4b3eb1"></a>struct <a class="el" href="group__avdecc__format.html#structavdecc__format">avdecc_format</a></td>
<td class="fieldname">
format</td>
<td class="fielddoc">
Stream media format (in network order) </td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a3198f25925618f12ae653d79a311f8b0"></a><a class="el" href="group__stream.html#gae169475c394476b5cfc78a81a8fbc8f9">genavb_stream_flags_t</a></td>
<td class="fieldname">
flags</td>
<td class="fielddoc">
Stream flags bitmap. </td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="aac9bd47624fe1bb12127c3150b883f98"></a><a class="el" href="group__stream.html#ga549fd464aad79090311d03274e0f5ffb">genavb_clock_domain_t</a></td>
<td class="fieldname">
clock_domain</td>
<td class="fielddoc">
Media clock domain used for this stream. </td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="ae98c93df5b7150142c227a4c2e6e5d6b"></a>struct <a class="el" href="group__stream.html#structgenavb__stream__params_8talker">genavb_stream_params</a></td>
<td class="fieldname">
talker</td>
<td class="fielddoc">
Talker specific parameters. </td></tr>
</table>

</div>
</div>
<a name="structgenavb__stream__params_8talker" id="structgenavb__stream__params_8talker"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct genavb_stream_params.talker</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"></div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a7883a7305bcbd394f768e04b9e800f53"></a>avb_u32</td>
<td class="fieldname">
latency</td>
<td class="fielddoc">
Stream processing latency/period in ns. <p>AVTP thread is woken periodically based on this setting to process pending media data for the stream. A low value reduces overall latency (between talker and listener), but increases CPU usage. A high value increases overall latency (between talker and listener), but decreases CPU usage. This setting is ignored for subtypes <a class="el" href="group__avtp.html#ga0745e21462cee245e293438b62dd7a51">AVTP_SUBTYPE_CRF</a>, <a class="el" href="group__avtp.html#ga8ee172fa8afc1979e822509d28195f8d">AVTP_SUBTYPE_TSCF</a> and <a class="el" href="group__avtp.html#ga4cd9f16db66fd1174a18f442c2131258">AVTP_SUBTYPE_NTSCF</a>.</p>
<p>In 1.x releases:</p><ul>
<li>Internally the stack uses a minimum value of 500us.</li>
<li>The maximum value is such that no more than 16 packets per stream are generated per period. That works out to around 4ms for Class B streams and 2ms for Class A.</li>
<li>The value is adjusted to always have an integer number of transmitted packets per period.</li>
<li>All talker streams from the same SR class must be created with the same latency setting (or creation will fail). </li>
</ul>
</td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="acd1dc8b73ae5f03ba65f2655aea9d05b"></a>avb_u16</td>
<td class="fieldname">
vlan_id</td>
<td class="fielddoc">
Vlan id for the stream (in network order), one of [VLAN_VID_MIN, VLAN_VID_MAX], VLAN_VID_DEFAULT or VLAN_VID_NONE. <p>For streams with a reservation, VLAN_VID_DEFAULT will use the vlan id of the SRP domain. VLAN_VID_NONE will result in a error. Any other value will override the SRP domain vlan id. For streams without a reservation, VLAN_VID_NONE/VLAN_VID_DEFAULT will result in frames with no vlan tag. Any other value will results in vlan tagged frames. </p>
</td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="ab988295c268025b49dfb3df26171ddc3"></a>avb_u8</td>
<td class="fieldname">
priority</td>
<td class="fielddoc">
(Vlan) priority for the stream, only used for streams without a reservation. <p>Must not overlap with SRP domain priorities </p>
</td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a0c6e298d2ad950100dd62fbc874f6f47"></a>avb_u16</td>
<td class="fieldname">
max_frame_size</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a2314354fa88af28e976f75c897f3fd7d"></a>avb_u16</td>
<td class="fieldname">
max_interval_frames</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="structgenavb__iovec" id="structgenavb__iovec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct genavb_iovec</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Scatter/gather array items. </p>
<p>The definition of this structure is copied from the standard Linux iovec struct, used e.g. in recvmsg, sendmsg calls. </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a9e94f0cd56f9590c293a2f4eb2a74d00"></a>void *</td>
<td class="fieldname">
iov_base</td>
<td class="fielddoc">
Starting address. </td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a9d06aa5e8f7270632bbc1d6a435cae91"></a>unsigned int</td>
<td class="fieldname">
iov_len</td>
<td class="fielddoc">
Number of bytes/events to transfer. </td></tr>
</table>

</div>
</div>
<a name="structgenavb__event" id="structgenavb__event"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct genavb_event</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Receive events: </p>
<ul>
<li><a class="el" href="group__stream.html#ga142b8be7c08359eaad4ba358ca439c4a" title="Media clock restart event, based on AVTP stream header mr bit. ">AVTP_MEDIA_CLOCK_RESTART</a> will be set if the mr bit is set for the first packet in the batch.</li>
<li><a class="el" href="group__stream.html#gaabac3d782b8271940bda704fc61af46a" title="AVTP packet loss event, base on AVTP stream format sequence number. ">AVTP_PACKET_LOST</a> will be set if a packet (or several) was lost at the start of the batch.</li>
<li><a class="el" href="group__stream.html#ga5b3fb974cb1ea2d99de92d85e786e938" title="End of frame event, based on AVTP CVF M bit. ">AVTP_END_OF_FRAME</a> will be set based on information contained in the AVTP header, such as the M bit in AVTP compressed video streams.</li>
</ul>
<p>As described in <a class="el" href="group__stream.html#ga3f6239c9a0914082dd5fd76f0507e5b4" title="Receive media data from a given avb stream. ">genavb_stream_receive</a>, <a class="el" href="group__stream.html#ga142b8be7c08359eaad4ba358ca439c4a" title="Media clock restart event, based on AVTP stream header mr bit. ">AVTP_MEDIA_CLOCK_RESTART</a> and <a class="el" href="group__stream.html#gaabac3d782b8271940bda704fc61af46a" title="AVTP packet loss event, base on AVTP stream format sequence number. ">AVTP_PACKET_LOST</a> shall only be set for the first <a class="el" href="group__stream.html#structgenavb__event" title="Receive events: ">genavb_event</a> of a batch. If <a class="el" href="group__stream.html#gaabac3d782b8271940bda704fc61af46a" title="AVTP packet loss event, base on AVTP stream format sequence number. ">AVTP_PACKET_LOST</a> is set, event_data will be used to store the amount of bytes lost.</p>
<p>Send events:</p><ul>
<li><a class="el" href="group__stream.html#ga31ffedf58931d498048116f43ba42cea" title="Synchronization event. ">AVTP_SYNC</a> can be set to synchronize batch transmit/avtp timestamp to the gptp time specified in the event ts field.</li>
<li><a class="el" href="group__stream.html#ga95b57551cb8d38631d7482b0cd7f7549" title="Flush event. ">AVTP_FLUSH</a> can be set as the first event to flush all stream data, up to the end of the data being sent through the single genavb_stream_send/genavb_stream_send_iov call that will include that event.</li>
<li><a class="el" href="group__stream.html#ga5a0a46f6e4ddfa6236496dae45c98198" title="End of frame event. ">AVTP_FRAME_END</a> can be set as the first event to signal that the last byte of the data being sent corresponds to the end of a frame (e.g end of a NALU in a CVF H264 stream). This will have the same effect as <a class="el" href="group__stream.html#ga95b57551cb8d38631d7482b0cd7f7549" title="Flush event. ">AVTP_FLUSH</a> also. </li>
</ul>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a class="anchor" id="ae1e4afc2bb01a3a6e39e466082f23006"></a>unsigned int</td>
<td class="fieldname">
event_mask</td>
<td class="fielddoc">
Receive event mask: <a class="el" href="group__stream.html#ga88c1c6af5065f0f5e009f83093df1a2a" title="AVTP timestamp invalid event, based on AVTP stream header tv bit. ">AVTP_TIMESTAMP_INVALID</a>, <a class="el" href="group__stream.html#ga36b7375f8d60ce9b0886814010a9fa1a" title="AVTP timestamp uncertain event, based on AVTP stream header tu bit. ">AVTP_TIMESTAMP_UNCERTAIN</a>, <a class="el" href="group__stream.html#ga142b8be7c08359eaad4ba358ca439c4a" title="Media clock restart event, based on AVTP stream header mr bit. ">AVTP_MEDIA_CLOCK_RESTART</a>, <a class="el" href="group__stream.html#gaabac3d782b8271940bda704fc61af46a" title="AVTP packet loss event, base on AVTP stream format sequence number. ">AVTP_PACKET_LOST</a>, <a class="el" href="group__stream.html#ga5b3fb974cb1ea2d99de92d85e786e938" title="End of frame event, based on AVTP CVF M bit. ">AVTP_END_OF_FRAME</a><br />
Send event mask: <a class="el" href="group__stream.html#ga31ffedf58931d498048116f43ba42cea" title="Synchronization event. ">AVTP_SYNC</a>, <a class="el" href="group__stream.html#ga95b57551cb8d38631d7482b0cd7f7549" title="Flush event. ">AVTP_FLUSH</a>, <a class="el" href="group__stream.html#ga5a0a46f6e4ddfa6236496dae45c98198" title="End of frame event. ">AVTP_FRAME_END</a>. </td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="abffea8212cdcc7310ca4ab63f5fc7d31"></a>unsigned int</td>
<td class="fieldname">
index</td>
<td class="fielddoc">
Receive/Send, offset of the event relative to the start of the batch, in bytes. </td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="ac96608e68a3144a944ef23cd023fcc52"></a>unsigned int</td>
<td class="fieldname">
ts</td>
<td class="fielddoc">
Receive AVTP timestamp of the event, if <a class="el" href="group__stream.html#ga88c1c6af5065f0f5e009f83093df1a2a" title="AVTP timestamp invalid event, based on AVTP stream header tv bit. ">AVTP_TIMESTAMP_INVALID</a> is not set in event_mask<br />
Send AVTP timestamp of the event, if <a class="el" href="group__stream.html#ga31ffedf58931d498048116f43ba42cea" title="Synchronization event. ">AVTP_SYNC</a> is set in event_mask. </td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="ab273bd24ad260f860267308903f42eec"></a>unsigned int</td>
<td class="fieldname">
event_data</td>
<td class="fielddoc">
Additional data, whose interpretation will depend on the type(s) of event. </td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="ga142b8be7c08359eaad4ba358ca439c4a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define AVTP_MEDIA_CLOCK_RESTART&#160;&#160;&#160;(1 &lt;&lt; 0)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Media clock restart event, based on AVTP stream header mr bit. </p>

</div>
</div>
<a class="anchor" id="gaeec7fa07053dd385e126e0d8cadb6006"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SR_CLASS_A_MAX_TIMING_UNCERTAINTY&#160;&#160;&#160;125000</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stream classes. </p>

</div>
</div>
<a class="anchor" id="gaabac3d782b8271940bda704fc61af46a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define AVTP_PACKET_LOST&#160;&#160;&#160;(1 &lt;&lt; 1)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>AVTP packet loss event, base on AVTP stream format sequence number. </p>

</div>
</div>
<a class="anchor" id="ga36b7375f8d60ce9b0886814010a9fa1a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define AVTP_TIMESTAMP_UNCERTAIN&#160;&#160;&#160;(1 &lt;&lt; 2)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>AVTP timestamp uncertain event, based on AVTP stream header tu bit. </p>

</div>
</div>
<a class="anchor" id="ga5b3fb974cb1ea2d99de92d85e786e938"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define AVTP_END_OF_FRAME&#160;&#160;&#160;(1 &lt;&lt; 14)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>End of frame event, based on AVTP CVF M bit. </p>

</div>
</div>
<a class="anchor" id="ga88c1c6af5065f0f5e009f83093df1a2a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define AVTP_TIMESTAMP_INVALID&#160;&#160;&#160;(1 &lt;&lt; 15)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>AVTP timestamp invalid event, based on AVTP stream header tv bit. </p>

</div>
</div>
<a class="anchor" id="ga31ffedf58931d498048116f43ba42cea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define AVTP_SYNC&#160;&#160;&#160;(1 &lt;&lt; 0)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Synchronization event. </p>

</div>
</div>
<a class="anchor" id="ga95b57551cb8d38631d7482b0cd7f7549"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define AVTP_FLUSH&#160;&#160;&#160;(1 &lt;&lt; 1)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flush event. </p>

</div>
</div>
<a class="anchor" id="ga5a0a46f6e4ddfa6236496dae45c98198"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define AVTP_FRAME_END&#160;&#160;&#160;(1 &lt;&lt; 2)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>End of frame event. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="ga85e282bda3eed89c6943b31df3b69515"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__stream.html#ga85e282bda3eed89c6943b31df3b69515">avtp_direction_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stream direction. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="gga85e282bda3eed89c6943b31df3b69515a63caa6b27fa2daedc4403e7291aeec4d"></a>AVTP_DIRECTION_LISTENER&#160;</td><td class="fielddoc">
<p>Listener direction, stream is received by entity. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga85e282bda3eed89c6943b31df3b69515a2ef2404bd96ea075fb8271c432144402"></a>AVTP_DIRECTION_TALKER&#160;</td><td class="fielddoc">
<p>Talker direction, stream is sent by entity. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ga549fd464aad79090311d03274e0f5ffb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__stream.html#ga549fd464aad79090311d03274e0f5ffb">genavb_clock_domain_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="gga549fd464aad79090311d03274e0f5ffbac4ba9bb2e9e1a4aa7239ef45cef8ce42"></a>GENAVB_MEDIA_CLOCK_DOMAIN_PTP&#160;</td><td class="fielddoc">
<p>Clock domain based on gPTP clock, should be used for talker media streaming (DEPRECATED) </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga549fd464aad79090311d03274e0f5ffba0260ee5b31eeb1468a3af56e7e47264a"></a>GENAVB_MEDIA_CLOCK_DOMAIN_STREAM&#160;</td><td class="fielddoc">
<p>Clock domain based on stream recovered clock, should be use for listener media playback (DEPRECATED) </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga549fd464aad79090311d03274e0f5ffba36e51ee61f4055e27b8eeaa91da8fba1"></a>GENAVB_MEDIA_CLOCK_DOMAIN_MASTER_CLK&#160;</td><td class="fielddoc">
<p>Clock domain based on the master clock driving the domain (codec) (DEPRECATED) </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga549fd464aad79090311d03274e0f5ffba8c091920cc20d6a31ae74f719c1b4862"></a>GENAVB_CLOCK_DOMAIN_0&#160;</td><td class="fielddoc">
<p>Clock domain 0. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga549fd464aad79090311d03274e0f5ffbaa486fe54ebfcb15d90293de73cf25017"></a>GENAVB_CLOCK_DOMAIN_1&#160;</td><td class="fielddoc">
<p>Clock domain 1. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga549fd464aad79090311d03274e0f5ffba1d360ef40b5c8360f5a4b13fc2cbd0af"></a>GENAVB_CLOCK_DOMAIN_2&#160;</td><td class="fielddoc">
<p>Clock domain 2. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga549fd464aad79090311d03274e0f5ffba616788badeb6b2e6a26608a0c22952aa"></a>GENAVB_CLOCK_DOMAIN_3&#160;</td><td class="fielddoc">
<p>Clock domain 3. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="gae169475c394476b5cfc78a81a8fbc8f9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__stream.html#gae169475c394476b5cfc78a81a8fbc8f9">genavb_stream_flags_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="ggae169475c394476b5cfc78a81a8fbc8f9acbf8c5c84576d43be7cc9e20767f0656"></a>GENAVB_STREAM_FLAGS_MCR&#160;</td><td class="fielddoc">
<p>Enable media clock recovery for the stream. </p>
<p>Only valid for listener streams and <a class="el" href="group__stream.html#gga549fd464aad79090311d03274e0f5ffba0260ee5b31eeb1468a3af56e7e47264a" title="Clock domain based on stream recovered clock, should be use for listener media playback (DEPRECATED) ...">GENAVB_MEDIA_CLOCK_DOMAIN_STREAM</a> clock domain </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggae169475c394476b5cfc78a81a8fbc8f9ad49344af8b4c68682fc51aa45d94eaf8"></a>GENAVB_STREAM_FLAGS_CUSTOM_TSPEC&#160;</td><td class="fielddoc">
<p>Enable custom tspec definition. </p>
<p>Only valid for talker streams </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ga3f41b80b144c62352d1b276e9efa99b8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__stream.html#ga3f41b80b144c62352d1b276e9efa99b8">genavb_stream_create_flags_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>genavb_stream_create flags </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="gga3f41b80b144c62352d1b276e9efa99b8ac185e51577304e6ae9515774d85eb714"></a>AVTP_NONBLOCK&#160;</td><td class="fielddoc">
<p>Create stream in non-blocking mode. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga3f41b80b144c62352d1b276e9efa99b8a199c3a08feba937f632cb892c89566b5"></a>AVTP_DGRAM&#160;</td><td class="fielddoc">
<p>Create stream in DATAGRAM mode. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga8b670c4f794059248df5d3554912d6ae"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int genavb_stream_fd </td>
          <td>(</td>
          <td class="paramtype">struct genavb_stream_handle const *&#160;</td>
          <td class="paramname"><em>stream</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the file descriptor associated with a given AVTP stream. </p>
<dl class="section return"><dt>Returns</dt><dd>socket/file descriptor (to be used with poll/select) for the stream, or negative error code. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>stream handle returned by genavb_stream_create. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gae0d4f045db318cc5fcc32bb699051ea9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int genavb_stream_h264_send </td>
          <td>(</td>
          <td class="paramtype">struct genavb_stream_handle *&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>data_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="group__stream.html#structgenavb__event">genavb_event</a> *&#160;</td>
          <td class="paramname"><em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>event_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send H264 media data on a given CVF H264 AVTP stream. </p>
<p>This is a special function to transmit H264 NALU buffers on an AVTP stream. It will pad the data buffer to take into account the different H264 packetization headers and avoid un-necessary memory copies. The data buffer can contain at most one NALU and the start of an NALU must always be at the start of the data buffer. It's valid for the data buffer to only contain a partial NALU (the beginning, a middle section or just the end) but the order of the byte stream must be respected. The last bytes of the NALU should be sent with an <a class="el" href="group__stream.html#ga5a0a46f6e4ddfa6236496dae45c98198" title="End of frame event. ">AVTP_FRAME_END</a> flag. The amount of data written at the start of a NALU must be sufficient to let the function decide the h264 packetization mode to use. If that's not the case -<a class="el" href="group__generic.html#gga031a0b2111b623fef60d707141a995d5a3fd82bb046ddbf4e49aad1e2ca17efa1" title="Stream data write error due to not enough data. ">GENAVB_ERR_STREAM_TX_NOT_ENOUGH_DATA</a> will be returned.</p>
<dl class="section return"><dt>Returns</dt><dd>amount copied (in bytes), or negative error code.<ul>
<li>The amount copied may be less than requested in case not enough network buffers were available.</li>
<li>The negative error code can be:</li>
<li>* -<a class="el" href="group__generic.html#gga031a0b2111b623fef60d707141a995d5a3fd82bb046ddbf4e49aad1e2ca17efa1" title="Stream data write error due to not enough data. ">GENAVB_ERR_STREAM_TX_NOT_ENOUGH_DATA</a>: This means that the data (the start of NALU sent) is less than what the function needs to decide on packetization mode. The caller needs to resend on next media stack wakeup either an amount of data equal to batch size or the full NALU (with <a class="el" href="group__stream.html#ga5a0a46f6e4ddfa6236496dae45c98198" title="End of frame event. ">AVTP_FRAME_END</a> flag).</li>
<li>* Any other negative error means a fatal error is encountred (e.g sending new NALU without <a class="el" href="group__stream.html#ga5a0a46f6e4ddfa6236496dae45c98198" title="End of frame event. ">AVTP_FRAME_END</a> flag for the previous NALU). </li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>stream handle returned by <a class="el" href="group__stream.html#ga1edca94485ef63e234a5012187255588" title="Create a new AVTP stream. ">genavb_stream_create</a>. </td></tr>
    <tr><td class="paramname">data</td><td>buffer containing the data to send. </td></tr>
    <tr><td class="paramname">data_len</td><td>length of the data in bytes. </td></tr>
    <tr><td class="paramname">event</td><td>event structure array timestamps/flags for the data to be sent (see <a class="el" href="group__stream.html#structgenavb__event" title="Receive events: ">genavb_event</a>). </td></tr>
    <tr><td class="paramname">event_len</td><td>length of the event array (in struct <a class="el" href="group__stream.html#structgenavb__event" title="Receive events: ">genavb_event</a> units) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gae648eae79fa8c289147375d0410945b1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int genavb_stream_receive_iov </td>
          <td>(</td>
          <td class="paramtype">struct genavb_stream_handle const *&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="group__stream.html#structgenavb__iovec">genavb_iovec</a> const *&#160;</td>
          <td class="paramname"><em>data_iov</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>data_iov_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="group__stream.html#structgenavb__iovec">genavb_iovec</a> const *&#160;</td>
          <td class="paramname"><em>event_iov</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>event_iov_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>event_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Receive media data from a given avb stream. </p>
<dl class="section return"><dt>Returns</dt><dd>amount copied (in bytes, or negative error code (e.g invalid handle for stream receive). May be less than requested by data_iov in case:<ul>
<li>not enough data is available,</li>
<li>event_iov cannot hold all the timestamps,</li>
<li>an EOF (End-Of-Frame) event was encountered,</li>
<li>of packet loss (will stop at last packet before sequence number discontinuity),</li>
<li>of media clock restart (mr bit set in AVTP header). For the last 2 cases, the data will stop at the last packet before the "event", i.e. last packet before the discontinuity, or last packet before the one with the mr bit set. flags will also be set on the <em>next</em> batch to signal the event at the start of that new batch. For the first 2 cases, no flags will be set and the call will be considered successful (data and timestamps are copied into data_iov and event_iov, whichever fills up first). For the EOF event, data will stop with the byte matching the EOF, so that the EOF will always be the last event returned. </li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>stream handle returned by <a class="el" href="group__stream.html#ga1edca94485ef63e234a5012187255588" title="Create a new AVTP stream. ">genavb_stream_create</a>. </td></tr>
    <tr><td class="paramname">data_iov</td><td>iovec array where stream data is to be copied. </td></tr>
    <tr><td class="paramname">data_iov_len</td><td>length of the data_iov array. </td></tr>
    <tr><td class="paramname">event_iov</td><td>iovec array where events are to be copied (see <a class="el" href="group__stream.html#structgenavb__event" title="Receive events: ">genavb_event</a>). For each of the <a class="el" href="group__stream.html#structgenavb__iovec" title="Scatter/gather array items. ">genavb_iovec</a>'s, the iov_base should point to an array of struct <a class="el" href="group__stream.html#structgenavb__event" title="Receive events: ">genavb_event</a> and iov_len must be in struct <a class="el" href="group__stream.html#structgenavb__event" title="Receive events: ">genavb_event</a> units. </td></tr>
    <tr><td class="paramname">event_iov_len</td><td>length of the event_iov array. If event_iov_len is equal to zero, only data will be returned. </td></tr>
    <tr><td class="paramname">event_len</td><td>On return, the event_len pointer will contain the number of events actually copied to the event iovecs. This function will return an error if event_len is NULL, but event_iov is not NULL or event_iov_len is not zero. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gab809c4255477d9a3745386f5aaedd791"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int genavb_stream_send_iov </td>
          <td>(</td>
          <td class="paramtype">struct genavb_stream_handle const *&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="group__stream.html#structgenavb__iovec">genavb_iovec</a> const *&#160;</td>
          <td class="paramname"><em>data_iov</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>data_iov_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="group__stream.html#structgenavb__event">genavb_event</a> const *&#160;</td>
          <td class="paramname"><em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>event_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send media data on a given AVTP stream. </p>
<dl class="section return"><dt>Returns</dt><dd>amount copied (in bytes), or negative error code (e.g invalid fd for stream receive). May be less than requested in case:<ul>
<li>not enough network buffers were available </li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>stream handle returned by <a class="el" href="group__stream.html#ga1edca94485ef63e234a5012187255588" title="Create a new AVTP stream. ">genavb_stream_create</a>. </td></tr>
    <tr><td class="paramname">data_iov</td><td>iovec array containing the data to send. </td></tr>
    <tr><td class="paramname">data_iov_len</td><td>length of the data_iov array. </td></tr>
    <tr><td class="paramname">event</td><td>event structure array timestamps/flags for the data to be sent (see <a class="el" href="group__stream.html#structgenavb__event" title="Receive events: ">genavb_event</a>). </td></tr>
    <tr><td class="paramname">event_len</td><td>length of the event array (in struct <a class="el" href="group__stream.html#structgenavb__event" title="Receive events: ">genavb_event</a> units) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga1edca94485ef63e234a5012187255588"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int genavb_stream_create </td>
          <td>(</td>
          <td class="paramtype">struct genavb_handle *&#160;</td>
          <td class="paramname"><em>genavb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct genavb_stream_handle **&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="group__stream.html#structgenavb__stream__params">genavb_stream_params</a> const *&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>batch_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__stream.html#ga3f41b80b144c62352d1b276e9efa99b8">genavb_stream_create_flags_t</a>&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new AVTP stream. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__generic.html#gga031a0b2111b623fef60d707141a995d5a652003ceb0485f27d4a45e7c29dffe7f" title="Success. ">GENAVB_SUCCESS</a> or negative error code. In case of success: stream argument is updated with stream handle, batch_size argument is updated with actual configured batch size. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">genavb</td><td>pointer to GenAVB library handle </td></tr>
    <tr><td class="paramname">stream</td><td>pointer to stream handle pointer </td></tr>
    <tr><td class="paramname">params</td><td>pointer to struct containing all required params. </td></tr>
    <tr><td class="paramname">batch_size</td><td>requested batch size in bytes. The media stack will be woken up <b>only</b> when the number of bytes free/available is equal or above batch size. After wakeup, the listener can always read batch size bytes and the talker can always write batch size bytes. This argument is updated on return with the actual configured value. In the listener case, this means the application will <b>never</b> be woken up by the stack if the number of bytes available never reaches batch size(as can happen for example at the end of a video stream). The application should implement a time-out mechanism and make appropriate <a class="el" href="group__stream.html#ga3f6239c9a0914082dd5fd76f0507e5b4" title="Receive media data from a given avb stream. ">genavb_stream_receive</a>/<a class="el" href="group__stream.html#gae648eae79fa8c289147375d0410945b1" title="Receive media data from a given avb stream. ">genavb_stream_receive_iov</a> calls to retrieve pending data if needed. </td></tr>
    <tr><td class="paramname">flags</td><td>may have the following bits set:<ul>
<li><a class="el" href="group__stream.html#gga3f41b80b144c62352d1b276e9efa99b8ac185e51577304e6ae9515774d85eb714" title="Create stream in non-blocking mode. ">AVTP_NONBLOCK</a> to have the send/receive functions return immediately with the currently available data, even if it less than requested. If this flag is not set, the function call will block until all requested data is received or transmitted. Blocking mode hasn't been implemented yet, so the send/receive functions will always behave in non-blocking mode. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga3f6239c9a0914082dd5fd76f0507e5b4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int genavb_stream_receive </td>
          <td>(</td>
          <td class="paramtype">struct genavb_stream_handle const *&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>data_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="group__stream.html#structgenavb__event">genavb_event</a> *&#160;</td>
          <td class="paramname"><em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>event_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Receive media data from a given avb stream. </p>
<dl class="section return"><dt>Returns</dt><dd>amount copied (in bytes, or negative error code (e.g invalid handle for stream receive). May be less than requested by data_len in case:<ul>
<li>not enough data is available,</li>
<li>event cannot hold all the timestamps,</li>
<li>an EOF (End-Of-Frame) event was encountered,</li>
<li>of packet loss (will stop at last packet before sequence number discontinuity),</li>
<li>of media clock restart (mr bit set in AVTP header). For the last 2 cases, the data will stop at the last packet before the "event", i.e. last packet before the discontinuity, or last packet before the one with the mr bit set. flags will also be set on the <em>next</em> batch to signal the event at the start of that new batch. For the first 2 cases, no flags will be set and the call will be considered successful (data and timestamps are copied into data_iov and event_iov, whichever fills up first). For the EOF event, data will stop with the byte matching the EOF, so that the EOF will always be the last event returned. </li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>stream handle returned by <a class="el" href="group__stream.html#ga1edca94485ef63e234a5012187255588" title="Create a new AVTP stream. ">genavb_stream_create</a>. </td></tr>
    <tr><td class="paramname">data</td><td>buffer where stream data is to be copied. </td></tr>
    <tr><td class="paramname">data_len</td><td>length of the data in bytes. </td></tr>
    <tr><td class="paramname">event</td><td>array where events matching the datas are to be copied (see <a class="el" href="group__stream.html#structgenavb__event" title="Receive events: ">genavb_event</a>). </td></tr>
    <tr><td class="paramname">event_len</td><td>pointer to the length of the event array (in struct <a class="el" href="group__stream.html#structgenavb__event" title="Receive events: ">genavb_event</a> units). On return, will contain the number of events actually present. If event_len is NULL, only data will be returned. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga04dfd629347336da56741cbabf021bf5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int genavb_stream_send </td>
          <td>(</td>
          <td class="paramtype">struct genavb_stream_handle const *&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>data_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="group__stream.html#structgenavb__event">genavb_event</a> const *&#160;</td>
          <td class="paramname"><em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>event_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send media data on a given AVTP stream. </p>
<dl class="section return"><dt>Returns</dt><dd>amount copied (in bytes), or negative error code (e.g invalid fd for stream receive). May be less than requested in case:<ul>
<li>not enough network buffers were available. </li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>stream handle returned by <a class="el" href="group__stream.html#ga1edca94485ef63e234a5012187255588" title="Create a new AVTP stream. ">genavb_stream_create</a>. </td></tr>
    <tr><td class="paramname">data</td><td>buffer containing the data to send. </td></tr>
    <tr><td class="paramname">data_len</td><td>length of the data in bytes. </td></tr>
    <tr><td class="paramname">event</td><td>event structure array timestamps/flags for the data to be sent (see <a class="el" href="group__stream.html#structgenavb__event" title="Receive events: ">genavb_event</a>). </td></tr>
    <tr><td class="paramname">event_len</td><td>length of the event array (in struct <a class="el" href="group__stream.html#structgenavb__event" title="Receive events: ">genavb_event</a> units) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga8ad1f9febe073b91fadc3b3aca802398"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int genavb_stream_destroy </td>
          <td>(</td>
          <td class="paramtype">struct genavb_stream_handle *&#160;</td>
          <td class="paramname"><em>stream</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy a given AVTP stream. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__generic.html#gga031a0b2111b623fef60d707141a995d5a652003ceb0485f27d4a45e7c29dffe7f" title="Success. ">GENAVB_SUCCESS</a> or negative error code. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>stream handle for the stream to be destroyed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga4f6aed0067e1082cb5937579af68f842"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int genavb_stream_presentation_offset </td>
          <td>(</td>
          <td class="paramtype">const struct genavb_stream_handle *&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the presentation offset for a given stream. </p>
<dl class="section return"><dt>Returns</dt><dd>Presentation offset (in ns) defining the lower limit of the <a class="el" href="group__stream.html#ga31ffedf58931d498048116f43ba42cea" title="Synchronization event. ">AVTP_SYNC</a> timestamps the stack will accept (for a talker stream), such that: &lt;AVTP_SYNC timestamp&gt; &gt;= &lt;current PTP time&gt; + &lt;presentation offset&gt; </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>Handle of the stream to get the presentation offset for. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.5-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul class="foot">
    <li class="footer"> &copy; 2017-2020 NXP
    </li>
  </ul>
</div>
</body>
</html>
